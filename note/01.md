

# 运行

终端运行node 文件名

**nodemon实现自动更新**

终端运行nodemon 文件名

# 模块

核心：不需要require。内置：不用install，需要require

![node](F:\图片\node.png)

## 第三方模块

### 1.npm i download-git-repo -S

实现从git上克隆代码到本地文件夹中，第一个参数写git地址，第二个参数写本地文件夹地址，第三个参数是回调函数，成功或失败时执行

### 2.npm i ora -S

实现下载时的显示过程，process = ora(下载时显示的内容) ，process.fail()显示失败图标，process.succeed()显示成功图标

```
const repo = 'github:su37josephxia/vue-template';
const test = '../test';
clone(repo,test);
function clone(repo,test) {
  const download = require('download-git-repo')
  const ora = require('ora')
  const process = ora(`正在下载${repo}`)
  process.start()
  download(repo, test, err => {
    if (err) {
      process.fail()
         } else {
      process.succeed()
    }
  })
}
```

### 3.npm i util -S 

实现将node转变为promise的写法，用同步方式写异步代码

```
const repo = 'github:su37josephxia/vue-template';
const test = '../test';
clone(repo,test);
 async function clone(repo,test) {
  const {promisify} = require('util')
  const download = promisify(require('download-git-repo'))
  const ora = require('ora')
  const process = ora(`正在下载${repo}`)
  process.start()
   try {
    await download(repo,test)
  } catch (error) {
    process.fail()
  }
  process.succeed()
 }
```

### 模块导出导入

```
module.exports.clone = async function.....
const {clone} = require('导出文件路径')
```

# 核心api

### fs：文件系统

```
const data = fs.readFileSync(路径) :同步调用
const data = fs.readFile(路径，(err,data)=>{}): 异步调用
console.log(data) 实际上读取的是二进制文件buffer
如果要读取真正的内容：console.log(data.toString())
```

### Buffer(重要)

读取数据类型为Buﬀer **由于读取的数据都是二进制值，为了操纵这个二进制值，需要使用Buffer，Buffer 类是用来处理二进制数据**

实际上buffer里面存的还是 0100011.... 这些，**只不过每8个字节显示成一个16进制数字**来给你看，所以当你真正使用的时候，需要指明特定的编解码方式(默认utf8)

8bit（位） = 1 byte（字节） 

```
//创建一个长度为10字节以0填充的Buffer
constbuf1=Buffer.alloc(10);
console.log(buf1);

Buffer.alloc：分配内存空间 第一个参数表示多少字节，第二个参数表示以什么填充
比如Buffer.alloc(10,22)
创建一个长度为10字节以十进制数22填充的Buffer
22先转换为二进制 10110，由于Buffer的数据显示是以16进制显示的=>10110转换为16进制为16
所以显示为：<Buffer 16 16 16 16 16 16 16 16 16 16>
```

```
//创建一个Buffer包含ascii.
//ascii查询http://ascii.911cha.com/
constbuf2=Buffer.from('a')
console.log(buf2,buf2.toString())

Buffer.from: 将某个值转换成Buffer数据
```

创建Buffer包含UTF-8字节//UFT-8：一种变长的编码方案，使用1~6个字节来存储；

```
constbuf3=Buffer.from('Buffer创建方法');
console.log(buf3);
```

写入数据

```
buf1.write('hello');console.log(buf1);
```

读取

```
console.log(buf3.toString());
```

合并

```
const buf4=Buffer.concat([buf1,buf3]);
```

### http

```
const http = require('http')
const fs = require('fs')
const server = http.createServer((request,response)=>{
  const {url,method} = request
  if(url === '/' && method === 'GET') {
    response.writeHead(200,{
      'Content-Type':'text/html'
    })
    response.end('hello')
  } else if(url === '/users'&& method === 'GET') {
    response.writeHead(200, {
      'Content-Type':'application/json'
    })
    response.end(JSON.stringify({
      name:'xiaoxu',
      age:'20'
    }))
  }
})
server.listen(3000)
```

### stream流操作(重要)

#### 流的基本概念及理解

> 流是一种数据传输手段，是有顺序的，有起点和终点，比如你要把数据从一个地方传到另外一个地方
>  流非常重要，gulp，webpack,HTTP里的请求和响应，http里的socket都是流，包括后面压缩，加密等
>
> 流为什么这么好用还这么重要呢？

- 因为有时候我们不关心文件的主体内容，只关心能不能取到数据，取到数据之后怎么进行处理
- 对于小型的文本文件，我们可以把文件内容全部读入内存，然后再写入文件，比如grunt-file-copy
- **对于体积较大的二进制文件，比如音频、视频文件，动辄几个GB大小，如果使用这种方法，很容易使内存“爆仓”。**
- **理想的方法应该是读一部分，写一部分，不管文件有多大，只要时间允许，总会处理完成，这里就需要用到流的概念**

> 流是一个抽象接口，被Node中很多对象所实现，比如HTTP服务器request和response对象都是流
>
> Node.js 中有四种基本的流类型：

- Readable - 可读的流 (例如 fs.createReadStream()).
- Writable - 可写的流 (例如 fs.createWriteStream()).
- Duplex - 可读写的流 (例如 net.Socket).
- Transform - 在读写过程中可以修改和变换数据的 Duplex 流 (例如 zlib.createDeflate()).

#### Readable streams可读流

> 可读流（Readable streams）是对提供数据的 源头（source）的抽象
>  可读流的例子包括：

- HTTP responses, on the client ：客户端请求
- HTTP requests, on the server ：服务端请求
- fs read streams ：读文件
- zlib streams ：压缩
- crypto streams ：加密
- TCP sockets ：TCP协议
- child process stdout and stderr ：子进程标准输出和错误输出
- process.stdin ：标准输入

> 下面简单举个可读流的例子：

- **监听可读流的data事件**，当你一旦开始监听data事件的时候，流就可以读文件的内容并且发射data，**读一点发射一点读一点发射一点**
- 默认情况下，当你监听data事件之后，会不停的读数据，然后触发data事件，触发完data事件后再次读数据
- **读的时候不是把文件整体内容读出来再发射出来的，而且设置一个缓冲区，大小默认是64K，比如文件是128K，先读64K发射出来，再读64K在发射出来，会发射两次**
- **缓冲区的大小可以通过highWaterMark来设置**

例子：

```
const fs = require('fs');
//通过创建一个可读流
const rs = fs.createReadStream('./1.txt',{
  flags:'r',//我们要对文件进行何种操作
  mode:0o666,//权限位
  encoding:'utf8',//不传默认为buffer，显示为字符串
  start:3,//从索引为3的位置开始读
  //这是我的见过唯一一个包括结束索引的
  end:8,//读到索引为8结束
  highWaterMark:3//缓冲区大小
});
rs.on('open',function () {
  console.log('文件打开');
});
rs.setEncoding('utf8');//显示为字符串
//希望流有一个暂停和恢复触发的机制
rs.on('data',function (data) {
  console.log(data);
  rs.pause();//暂停读取和发射data事件
  setTimeout(function(){
    rs.resume();//恢复读取并触发data事件
  },2000);
});
//如果读取文件出错了，会触发error事件
rs.on('error',function () {
  console.log("error");
});
//如果文件的内容读完了，会触发end事件
rs.on('end',function () {
  console.log('读完了');
});
rs.on('close',function () {
  console.log('文件关闭');
});

```

其中1.txt的内容是123456789

则打印出来的内容是：

```
/**
文件打开
456
789
读完了
文件关闭
**/
```

#### Writable streams可写流

> 可写流是对数据写入'目的地'的一种抽象
>  Writable：可写流的例子包括了：

- HTTP requests, on the client  客户端请求
- HTTP responses, on the server 服务器响应
- fs write streams 文件
- zlib streams 压缩
- crypto streams 加密
- TCP sockets TCP服务器
- child process stdin 子进程标准输入
- process.stdout, process.stderr 标准输出，错误输出

> 下面举个可写流的简单例子

- **当你往可写流里写数据的时候，不是会立刻写入文件的，而是会很写入缓存区，缓存区的大小就是highWaterMark,默认值是16K。然后等缓存区满了之后再次真正的写入文件里**

```javascript
let fs = require('fs');
let ws = fs.createWriteStream('./2.txt',{
   flags:'w',
   mode:0o666,
   start:3,
   highWaterMark:3//默认是16K
});
```

- 如果缓存区已满 ，返回false,如果缓存区未满，返回true
- 如果能接着写，返回true,如果不能接着写，返回false
- 按理说如果返回了false,就不能再往里面写了，但是如果你真写了，如果也不会丢失，会缓存在内存里。等缓存区清空之后再从内存里读出来



```javascript
let flag = ws.write('1');
console.log(flag);//true
flag =ws.write('2');
console.log(flag);//true
flag =ws.write('3');
console.log(flag);//false 这里满3了，所以返回false
flag =ws.write('4');
console.log(flag);//false
```

### **NodeJs的Buffer缓存与流式操作（重要）**

```
let fs = require("fs");

//创建可读流
let readF = fs.createReadStream("文件路径");
//创建可写流
let writeF = fs.createWriteStream("文件路径2");
readF.on("data",function(data){
   writeF.write(data);
   //写入可写流
});

readF.once("close",function(){
//监听可读流关闭
    writeF.end();
    //关闭可写流
});
```

上面的代码可以直接通过pipe方法转换成：

```
readF.pipe(writeF)
```

#### 项目小例子

```
 
 // response.end('hello ...')
  const { url, method ,headers} = request
  if (url === '/' && method === 'GET'){
    // 静态页面服务
    fs.readFile('index.html',(err,data) => {
      response.statusCode = 200
      response.setHeader('Content-Type','text/html')
      response.end(data)
    })
  }else if(url === '/users' && method === 'GET'){
    // Ajax服务
    response.writeHead(200,{
      'Content-Type': 'application/json'
    })
    response.end(JSON.stringify({
      name : 'laowang'
    }))
  }else if(method === 'GET' && headers.accept.indexOf('image/*') !== -1){
    // 图片文件服务 index.html里有图片
    fs.createReadStream('./'+url).pipe(response)
  }
  server.listen(3000)
  
  图文文件服务采用流操作，如果访问3000/，则以流的方式渲染图片
```

**Accept代表发送端（客户端）希望接受的数据类型。比如：Accept：text/xml;代表客户端希望接受的数据类型是xml类型。**
**Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。比如：Content-Type：text/html;代表发送端发送的数据格式是html。**

**二者合起来，Accept:text/xml；Content-Type:text/html，即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。**

# 自定义cli工具链

 mkdir vue-auto-router-cli 

cd vue-auto-router-cli 

npminit-y

**vue-auto-router-cli 文件下建bin文件夹**

> bin文件夹里是可执行的二进制文件
>
> lib文件夹里是库文件

**bin文件夹下创建kkb文件**

```
#!/usr/bin/envnode
console.log('cli...')
```

在package.json中添加

```
"bin": {
    "kkb": "./bin/kkb"
  },
```

npm link

执行kkb

=> cli....

构建：

```
#!/usr/bin/envnode
const program = require('commander')
program.version(require('../package').version, '-v', '--version')
    .command('init <name>', 'init project')
    .command('refresh','refresh routers...')
program.parse(process.argv)
```

**建立kkb-init文件夹**

```
#!/usr/bin/env node
const program = require('commander')
program
    .action(name => {
            console.log('init '+ name)
    })
program.parse(process.argv)
```

执行kkb init abc => init abc

**将api文件夹中的modulesdownload.js复制到lib文件夹下**

在kkb-init中调用

```
#!/usr/bin/env node
const program = require('commander')
const {clone} = require('../lib/modulesdownload.js')
program
    .action(async name => {
           // console.log('init '+ name)
            console.log('🚀创建项目:' + name)
           // 从github克隆项目到指定文件夹
            await clone('github:su37josephxia/vue-template',name)
    })
program.parse(process.argv)
```

然后终端输入 kkb init test，创建test文件夹来clone git上的项目

终端进入test文件，npm i 来安装包

npm run serve来运行

**实现每新建一个vue页面 ，都自动刷新，添加到vue主页的导航上去**

**原理**

每写一个vue页面，都自动添加到router.js,并自动添加到App.Vue的路由占位符上去

1.建立kkb-refresh实现

2.test终端kkb refresh

3.刷新test终端： npm run serve